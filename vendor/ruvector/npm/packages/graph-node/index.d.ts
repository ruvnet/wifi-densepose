/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Distance metric for similarity calculation */
export const enum JsDistanceMetric {
  Euclidean = 'Euclidean',
  Cosine = 'Cosine',
  DotProduct = 'DotProduct',
  Manhattan = 'Manhattan'
}
/** Graph database configuration options */
export interface JsGraphOptions {
  /** Distance metric for embeddings */
  distanceMetric?: JsDistanceMetric
  /** Vector dimensions */
  dimensions?: number
  /** Storage path */
  storagePath?: string
}
/** Node in the graph */
export interface JsNode {
  /** Node ID */
  id: string
  /** Node embedding */
  embedding: Float32Array
  /** Node labels (e.g., ["Person", "Employee"]) */
  labels?: Array<string>
  /** Optional properties */
  properties?: Record<string, string>
}
/** Edge between two nodes */
export interface JsEdge {
  /** Source node ID */
  from: string
  /** Target node ID */
  to: string
  /** Edge description/label */
  description: string
  /** Edge embedding */
  embedding: Float32Array
  /** Confidence score (0.0-1.0) */
  confidence?: number
  /** Optional metadata */
  metadata?: Record<string, string>
}
/** Hyperedge connecting multiple nodes */
export interface JsHyperedge {
  /** Node IDs connected by this hyperedge */
  nodes: Array<string>
  /** Natural language description of the relationship */
  description: string
  /** Embedding of the hyperedge description */
  embedding: Float32Array
  /** Confidence weight (0.0-1.0) */
  confidence?: number
  /** Optional metadata */
  metadata?: Record<string, string>
}
/** Query for searching hyperedges */
export interface JsHyperedgeQuery {
  /** Query embedding */
  embedding: Float32Array
  /** Number of results to return */
  k: number
}
/** Hyperedge search result */
export interface JsHyperedgeResult {
  /** Hyperedge ID */
  id: string
  /** Similarity score */
  score: number
}
/** Node result from query (without embedding) */
export interface JsNodeResult {
  /** Node ID */
  id: string
  /** Node labels */
  labels: Array<string>
  /** Node properties */
  properties: Record<string, string>
}
/** Edge result from query */
export interface JsEdgeResult {
  /** Edge ID */
  id: string
  /** Source node ID */
  from: string
  /** Target node ID */
  to: string
  /** Edge type/label */
  edgeType: string
  /** Edge properties */
  properties: Record<string, string>
}
/** Query result */
export interface JsQueryResult {
  /** Nodes returned by the query */
  nodes: Array<JsNodeResult>
  /** Edges returned by the query */
  edges: Array<JsEdgeResult>
  /** Optional statistics */
  stats?: JsGraphStats
}
/** Graph statistics */
export interface JsGraphStats {
  /** Total number of nodes */
  totalNodes: number
  /** Total number of edges */
  totalEdges: number
  /** Average node degree */
  avgDegree: number
}
/** Batch insert data */
export interface JsBatchInsert {
  /** Nodes to insert */
  nodes: Array<JsNode>
  /** Edges to insert */
  edges: Array<JsEdge>
}
/** Batch insert result */
export interface JsBatchResult {
  /** IDs of inserted nodes */
  nodeIds: Array<string>
  /** IDs of inserted edges */
  edgeIds: Array<string>
}
/** Temporal granularity */
export const enum JsTemporalGranularity {
  Hourly = 'Hourly',
  Daily = 'Daily',
  Monthly = 'Monthly',
  Yearly = 'Yearly'
}
/** Temporal hyperedge */
export interface JsTemporalHyperedge {
  /** Base hyperedge */
  hyperedge: JsHyperedge
  /** Creation timestamp (Unix epoch seconds) */
  timestamp: number
  /** Optional expiration timestamp */
  expiresAt?: number
  /** Temporal context */
  granularity: JsTemporalGranularity
}
/** Get the version of the library */
export declare function version(): string
/** Test function to verify bindings */
export declare function hello(): string
/** Streaming query result iterator */
export declare class QueryResultStream {
  /**
   * Get the next result from the stream
   *
   * # Example
   * ```javascript
   * const stream = await db.queryStream('MATCH (n) RETURN n');
   * while (true) {
   *   const result = await stream.next();
   *   if (!result) break;
   *   console.log(result);
   * }
   * ```
   */
  next(): JsQueryResult | null
}
/** Streaming hyperedge result iterator */
export declare class HyperedgeStream {
  /**
   * Get the next hyperedge result
   *
   * # Example
   * ```javascript
   * const stream = await db.searchHyperedgesStream(query);
   * for await (const result of stream) {
   *   console.log(result);
   * }
   * ```
   */
  next(): JsHyperedgeResult | null
  /** Collect all remaining results */
  collect(): Array<JsHyperedgeResult>
}
/** Node stream iterator */
export declare class NodeStream {
  /** Get the next node */
  next(): JsNode | null
  /** Collect all remaining nodes */
  collect(): Array<JsNode>
}
/** Graph database for complex relationship queries */
export declare class GraphDatabase {
  /**
   * Create a new graph database
   *
   * # Example
   * ```javascript
   * const db = new GraphDatabase({
   *   distanceMetric: 'Cosine',
   *   dimensions: 384
   * });
   * ```
   */
  constructor(options?: JsGraphOptions | undefined | null)
  /**
   * Open an existing graph database from disk
   *
   * # Example
   * ```javascript
   * const db = GraphDatabase.open('./my-graph.db');
   * ```
   */
  static open(path: string): GraphDatabase
  /**
   * Check if persistence is enabled
   *
   * # Example
   * ```javascript
   * if (db.isPersistent()) {
   *   console.log('Data is being saved to:', db.getStoragePath());
   * }
   * ```
   */
  isPersistent(): boolean
  /** Get the storage path (if persisted) */
  getStoragePath(): string | null
  /**
   * Create a node in the graph
   *
   * # Example
   * ```javascript
   * const nodeId = await db.createNode({
   *   id: 'node1',
   *   embedding: new Float32Array([1, 2, 3]),
   *   properties: { name: 'Alice', age: 30 }
   * });
   * ```
   */
  createNode(node: JsNode): Promise<string>
  /**
   * Create an edge between two nodes
   *
   * # Example
   * ```javascript
   * const edgeId = await db.createEdge({
   *   from: 'node1',
   *   to: 'node2',
   *   description: 'knows',
   *   embedding: new Float32Array([0.5, 0.5, 0.5]),
   *   confidence: 0.95
   * });
   * ```
   */
  createEdge(edge: JsEdge): Promise<string>
  /**
   * Create a hyperedge connecting multiple nodes
   *
   * # Example
   * ```javascript
   * const hyperedgeId = await db.createHyperedge({
   *   nodes: ['node1', 'node2', 'node3'],
   *   description: 'collaborated_on_project',
   *   embedding: new Float32Array([0.3, 0.6, 0.9]),
   *   confidence: 0.85,
   *   metadata: { project: 'AI Research' }
   * });
   * ```
   */
  createHyperedge(hyperedge: JsHyperedge): Promise<string>
  /**
   * Query the graph using Cypher-like syntax
   *
   * # Example
   * ```javascript
   * const results = await db.query('MATCH (n) RETURN n LIMIT 10');
   * ```
   */
  query(cypher: string): Promise<JsQueryResult>
  /**
   * Query the graph synchronously
   *
   * # Example
   * ```javascript
   * const results = db.querySync('MATCH (n) RETURN n LIMIT 10');
   * ```
   */
  querySync(cypher: string): JsQueryResult
  /**
   * Search for similar hyperedges
   *
   * # Example
   * ```javascript
   * const results = await db.searchHyperedges({
   *   embedding: new Float32Array([0.5, 0.5, 0.5]),
   *   k: 10
   * });
   * ```
   */
  searchHyperedges(query: JsHyperedgeQuery): Promise<Array<JsHyperedgeResult>>
  /**
   * Get k-hop neighbors from a starting node
   *
   * # Example
   * ```javascript
   * const neighbors = await db.kHopNeighbors('node1', 2);
   * ```
   */
  kHopNeighbors(startNode: string, k: number): Promise<Array<string>>
  /**
   * Begin a new transaction
   *
   * # Example
   * ```javascript
   * const txId = await db.begin();
   * ```
   */
  begin(): Promise<string>
  /**
   * Commit a transaction
   *
   * # Example
   * ```javascript
   * await db.commit(txId);
   * ```
   */
  commit(txId: string): Promise<void>
  /**
   * Rollback a transaction
   *
   * # Example
   * ```javascript
   * await db.rollback(txId);
   * ```
   */
  rollback(txId: string): Promise<void>
  /**
   * Batch insert nodes and edges
   *
   * # Example
   * ```javascript
   * await db.batchInsert({
   *   nodes: [{ id: 'n1', embedding: new Float32Array([1, 2]) }],
   *   edges: [{ from: 'n1', to: 'n2', description: 'knows' }]
   * });
   * ```
   */
  batchInsert(batch: JsBatchInsert): Promise<JsBatchResult>
  /**
   * Subscribe to graph changes (returns a change stream)
   *
   * # Example
   * ```javascript
   * const unsubscribe = db.subscribe((change) => {
   *   console.log('Graph changed:', change);
   * });
   * ```
   */
  subscribe(callback: (...args: any[]) => any): void
  /**
   * Get graph statistics
   *
   * # Example
   * ```javascript
   * const stats = await db.stats();
   * console.log(`Nodes: ${stats.totalNodes}, Edges: ${stats.totalEdges}`);
   * ```
   */
  stats(): Promise<JsGraphStats>
}
