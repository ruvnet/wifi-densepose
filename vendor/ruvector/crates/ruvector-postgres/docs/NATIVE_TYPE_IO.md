# Native PostgreSQL Type I/O Functions for RuVector

## Overview

This document describes the native PostgreSQL type I/O functions implementation for the `RuVector` type, providing zero-copy access like pgvector.

## Implementation Summary

### Memory Layout

The `RuVector` type uses a pgvector-compatible varlena layout:

```
┌─────────────┬─────────────┬─────────────┬──────────────────────┐
│  VARHDRSZ   │ dimensions  │   unused    │    f32 data...       │
│  (4 bytes)  │  (2 bytes)  │  (2 bytes)  │  (4 * dims bytes)    │
└─────────────┴─────────────┴─────────────┴──────────────────────┘
```

- **VARHDRSZ** (4 bytes): PostgreSQL varlena header
- **dimensions** (2 bytes u16): Number of dimensions (max 16,000)
- **unused** (2 bytes): Padding for 8-byte alignment
- **data**: f32 values (4 bytes each)

### Type I/O Functions

Four C-compatible functions are exported for PostgreSQL type system integration:

#### 1. `ruvector_in` - Text Input

Parses text format `'[1.0, 2.0, 3.0]'` to varlena structure.

**Features:**
- Validates UTF-8 encoding
- Checks for NaN and Infinity
- Supports integer notation (converts to f32)
- Returns PostgreSQL Datum pointing to varlena

**Example:**
```sql
SELECT '[1.0, 2.0, 3.0]'::ruvector;
```

#### 2. `ruvector_out` - Text Output

Converts varlena structure to text format `'[1.0, 2.0, 3.0]'`.

**Features:**
- Efficient string formatting
- Memory allocated in PostgreSQL context
- Returns null-terminated C string

**Example:**
```sql
SELECT my_vector::text;
```

#### 3. `ruvector_recv` - Binary Input

Receives vector from network in binary format (for COPY and replication).

**Binary Format:**
- 2 bytes: dimensions (network byte order / big-endian)
- 4 bytes × dimensions: f32 values (IEEE 754, network byte order)

**Features:**
- Network byte order handling
- Validates dimensions and float values
- Rejects NaN and Infinity

#### 4. `ruvector_send` - Binary Output

Sends vector in binary format over network.

**Features:**
- Network byte order conversion
- Efficient binary serialization
- Compatible with `ruvector_recv`

## Zero-Copy Access

### Reading (from PostgreSQL to Rust)

The `from_varlena` method provides zero-copy access to PostgreSQL memory:

```rust
unsafe fn from_varlena(varlena_ptr: *const pgrx::pg_sys::varlena) -> Self {
    // Get pointer to data (skip varlena header)
    let data_ptr = pgrx::varlena::vardata_any(varlena_ptr) as *const u8;

    // Read dimensions directly
    let dimensions = ptr::read_unaligned(data_ptr as *const u16);

    // Get pointer to f32 data (zero-copy slice)
    let f32_ptr = data_ptr.add(4) as *const f32;
    let data = std::slice::from_raw_parts(f32_ptr, dimensions as usize);

    // Only copy needed for Rust ownership
    RuVector { dimensions, data: data.to_vec() }
}
```

### Writing (from Rust to PostgreSQL)

The `to_varlena` method allocates in PostgreSQL memory context:

```rust
unsafe fn to_varlena(&self) -> *mut pgrx::pg_sys::varlena {
    // Allocate PostgreSQL memory
    let varlena_ptr = pgrx::pg_sys::palloc(total_size);

    // Write directly to PostgreSQL memory
    let data_ptr = pgrx::varlena::vardata_any(varlena_ptr);
    ptr::write_unaligned(data_ptr as *mut u16, dimensions);

    // Copy f32 data
    let f32_ptr = data_ptr.add(4) as *mut f32;
    ptr::copy_nonoverlapping(self.data.as_ptr(), f32_ptr, dimensions);

    varlena_ptr
}
```

## SQL Registration

To register the type with PostgreSQL, use the following SQL (generated by pgrx):

```sql
CREATE TYPE ruvector;

CREATE FUNCTION ruvector_in(cstring)
RETURNS ruvector
AS 'MODULE_PATHNAME', 'ruvector_in'
LANGUAGE C IMMUTABLE STRICT PARALLEL SAFE;

CREATE FUNCTION ruvector_out(ruvector)
RETURNS cstring
AS 'MODULE_PATHNAME', 'ruvector_out'
LANGUAGE C IMMUTABLE STRICT PARALLEL SAFE;

CREATE FUNCTION ruvector_recv(internal)
RETURNS ruvector
AS 'MODULE_PATHNAME', 'ruvector_recv'
LANGUAGE C IMMUTABLE STRICT PARALLEL SAFE;

CREATE FUNCTION ruvector_send(ruvector)
RETURNS bytea
AS 'MODULE_PATHNAME', 'ruvector_send'
LANGUAGE C IMMUTABLE STRICT PARALLEL SAFE;

CREATE TYPE ruvector (
    INPUT = ruvector_in,
    OUTPUT = ruvector_out,
    RECEIVE = ruvector_recv,
    SEND = ruvector_send,
    STORAGE = extended,
    ALIGNMENT = double,
    INTERNALLENGTH = VARIABLE
);
```

## Usage Examples

### Basic Vector Operations

```sql
-- Create vector from text
SELECT '[1.0, 2.0, 3.0]'::ruvector;

-- Insert into table
CREATE TABLE embeddings (
    id serial PRIMARY KEY,
    vec ruvector
);

INSERT INTO embeddings (vec) VALUES ('[1.0, 2.0, 3.0]');

-- Query and display
SELECT id, vec::text FROM embeddings;
```

### Binary I/O (COPY)

```sql
-- Export vectors in binary format
COPY embeddings TO '/tmp/vectors.bin' (FORMAT binary);

-- Import vectors in binary format
COPY embeddings FROM '/tmp/vectors.bin' (FORMAT binary);
```

## Performance Characteristics

### Memory Layout Benefits

1. **SIMD-Ready**: 8-byte alignment enables AVX/AVX2/AVX-512 operations
2. **Cache-Friendly**: Contiguous f32 array improves cache locality
3. **Compact**: 4-byte header + data (same as pgvector)

### Zero-Copy Advantages

1. **Read Performance**: Direct pointer access to PostgreSQL memory
2. **Write Performance**: Single allocation + memcpy
3. **Network Efficiency**: Binary format avoids text parsing overhead

## Compatibility

- **pgvector Compatible**: Same memory layout enables migration
- **pgrx 0.12**: Uses proper pgrx/PostgreSQL APIs
- **PostgreSQL 14-17**: Compatible with all supported versions
- **Endianness**: Network byte order for binary I/O ensures portability

## Testing

Run the test suite:

```bash
cargo test --package ruvector-postgres --lib types::vector::tests
```

Integration tests verify:
- Text input/output roundtrip
- Binary input/output roundtrip
- NaN/Infinity rejection
- Dimension validation
- Memory layout correctness

## Security Considerations

1. **Input Validation**: All inputs validated for:
   - Maximum dimensions (16,000)
   - NaN and Infinity values
   - Proper varlena structure
   - UTF-8 encoding

2. **Memory Safety**: All unsafe code carefully reviewed for:
   - Pointer validity
   - Alignment requirements
   - PostgreSQL memory context usage
   - No use-after-free

3. **DoS Protection**: Dimension limits prevent memory exhaustion

## Implementation Files

- **Main Implementation**: `/home/user/ruvector/crates/ruvector-postgres/src/types/vector.rs`
- **Type System Integration**: Lines 371-520
- **Zero-Copy Functions**: Lines 193-272
- **Tests**: Lines 576-721

## Future Enhancements

1. **Compressed Storage**: TOAST compression for large vectors
2. **SIMD Parsing**: Vectorized text parsing
3. **Inline Storage**: Small vector optimization (<= 128 bytes)
4. **Parallel COPY**: Multi-threaded binary I/O

## References

- [PostgreSQL Type System Documentation](https://www.postgresql.org/docs/current/xtypes.html)
- [pgvector Source](https://github.com/pgvector/pgvector)
- [pgrx Documentation](https://github.com/pgcentralfoundation/pgrx)
